\section*{Introduction and structure}

This project will be focused on implementing and comparing various
voxel acceleration structures for ray marching voxel scenes. Voxel
ray marching is the process of determining the onscreen pixel colour based
on traversing a ray through a 3D grid. This traversal can be accelerated through
the use of these acceleration structures, where the distance stepped along the
ray can be non uniform depending on the geometry of the scene,
decreasing the number of intersection tests required by the ray,
and possibly reducing the memory usage of the scene data.

For the ray-marching one possible approach is to implement a
wavefront\cite{laine2013wavefront} based approach. This approach
involves separating the individual stages of the ray-casting into individual
shaders, instead of all stages occurring in the same `mega kernel'. This should
result in performance improvements at the cost of some additional
memory requirements for the additional buffers.

The simplest structure is a 3D grid, in which DDA (digital
differential analyser)\cite{amanatides1987fast} can be used to
traverse the grid. DDA can be expanded to traverse non uniform space,
which leads to octrees\cite{laine2010svo} and contrees. These are
tree structures where each node has either $8$ or $64$ children
respectively, and the leaves represent the individual voxels. These
two methods can be combined to form brick
maps\cite{van2015brickmap}, where each node of the tree is actual
a `brick' of voxels, an $n*n*n$ collection. This combines some of the
benefits of the two styles.

This project aims to compare each of the methods against each other.
This comparison can be done both quantitatively and qualitatively.
The methods can be compared quantitatively by measuring the
memory consumption, render times, GPU register pressure and
intersection count of each method.
Qualitatively the methods can be measured based on the how `easy' the
structures are to modify, generate and serialize. `easy' being subjective
for how much additional work is required.

While comparison of these structures has been done previously, the comparison
of these structures with regards to split rendering has not. Another aim is to
compare these structures in areas that are not directly quantitative,
in particular with what may be required to modify and regenerate the structures
during runtime.

The results of this project should help inform others on which
acceleration structure may be suitable for their own project, this
may come from the direct metrics obtained from the acceleration
structures or from the qualitative analysis of the methods.
The application should also provide an interactive way to observe these
comparisons directly by allowing a user to change between differing scenes
and structures and directly see the performance results on their own machines.

The project will be written in C++, with Vulkan as the chosen rendering API,
less for its performance and more for its flexibility.
Slang will be used as the shader language as this can allow for hot reloading
of shaders as the compiler can be implemented with the rest of the project.

A summary of each structures is below
\begin{itemize}[noitemsep]
  \item 3D grids \\
    Each voxel is individual within a 3D grid. DDA can be used to
    trace through the grid and check for collisions. This can be
    represented directly through a buffer on the GPU. Indexing of the buffer
    can be done by either flattening the grid index or using a Z-order curve
    to improve spatial location of the indexing.
  \item 3D textures \\
    Uses the GPU architecture to help with memory lookups. Mipmaps
    can be used to implement level of detail and occupancy checks.
  \item Octrees \\
    A tree where each node has 8 children. In particular sparse octrees will be
    used allowing the tree to have a varying depth. The voxels themselves are
    represented by the leaf nodes.
  \item Contrees \\
    Similar to octrees except each node of the tree has $64$ children
    instead of $8$.
  \item Brick map \\
    A mix between octrees and 3D grids. Similar to the octree in
    being a tree structure, except each leaf node is composed of a `brick', an
    $n*n*n$ collection of voxels.
\end{itemize}

\subsection*{Core project}
The core element of the project involves implementing the ray marcher
for each structure, and implementing a system that should allow
for easy swapping between them. This system should also allow for different
scenes to be loaded, so that each structure can be compared in various layouts.
These scenes can either be generated programmatically, or
alternatively by generating voxels based on a mesh. This skin of a mesh can
be generated by checking if any triangle of a mesh intersects a grid of cubes.

Along with the rendering of these structures another aim is to allow
modification to them. The modification of the structures should allow
for addition, replacement and removal of voxels, while also allowing
for multiple voxels to be affected as apposed to a single voxel with
each operation.

The final goal of the core project is to evaluate the structures against each
other based on the render time, memory usage and register pressure on
the GPU, along
with evaluating the structures based on qualitative features.

\subsection*{Extensions}
The extensions of this project aim to add additional functionality,
with the main extension being split rendering, which is the process of
rendering the scene across multiple compute nodes. In particular this
may involve partial rendering or pre-processing of the scene on one node, and
then completing the rendering and displaying of the scene on a separate
client-node. This reduces the computation power required on the
client-node as some of the computationally intensive work can be
moved to a node with more computation.

Another extension could be generation of larger then memory scenes,
requiring streaming of data from disk to the GPU, while at the same
time offloading data from the GPU to disk in order to reserve memory
as needed.
