\section*{Introduction and structure}

This project will be focused on implementing and comparing various
acceleration structures that are targeted towards voxel ray marching.
These structures are designed to increase the efficiency at which a
ray can be traversed through space in order to check for collisions with
voxels.

The simplest structure is a 3D grid, in which DDA can be used to
traverse the grid. DDA can be expanded to traverse non uniform space,
which leads to octrees and contrees. These are tree structures where
each node has either $8$ or $64$ children respectively, and the leaves
represent the individual voxels. These two methods can be combined to
form brick maps, where each node of the tree is actual a `brick' of voxels,
an $n*n*n$ collection. This combines some of the benefits of the two styles.

This project aims to compare these methods to each other, comparing
particularly for the rendering efficiency in the methods. This
can be expanded to compare the memory efficiency, ease of modification,
and ease of generation.

The goal is to hit performance suitable for real-time rendering, from each
of the methods. This may not be suitable for some of the structures
for all scenes.
Performance can be additionally compared based on the theoretical
intersection count and the actual observed count. This can be
pushed further by looking at the register pressure on the GPU for
the shaders that are used. This requires external tooling, either
Nsight graphics for Nvidia cards or AMD's developer tool suite for AMD graphics.

The project will be written in C++, with vulkan as the chosen rendering API,
less for its performance and more for its flexibility.
Slang will be used as the shader language as this can allow for hot reloading
of shaders as the compiler can be implemented with the rest of the project.
Only a few external libraries will be required, these are used to reduce the
boilerplate required and to help with the setup of vulkan. These libraries
are
\begin{itemize}
  \item GLFW: A cross platform windowing library that can also handle inputs.
  \item GLM: A maths library targeted towards OpenGL but also
    functional with Vulkan.
  \item ImGui: Immediate mode GUI, simple to use, and flexible UI library.
  \item slang: Compiler for the slang shader language.
  \item vk-bootstrap: Simplifies initialization of vulkan.
  \item VulkanMemoryAllocator: Helps with memory allocation within vulkan.
\end{itemize}

A summary of each structures is below
\begin{itemize}
  \item 3D grids \\
    Each voxel is individual within a 3D grid. DDA can be used to
    trace through the grid and check for collisions.
  \item 3D textures \\
    Uses the GPU architecture to help with memory lookups. Mipmaps
    can be used to implement level of detail and occupancy checks.
  \item Octrees \\
    A tree where each node has 8 children. In particular sparse octrees will be
    used allowing the tree to have a varying depth. The voxels themselves are
    represented by the leaf nodes.
  \item Contrees \\
    Each node of the tree has $64$ children instead of $8$.
  \item Brick map \\
    A mix between octrees and 3D grids. Similar to the octree in
    being a tree structure, except each leaf node is composed of a `brick', an
    $n*n*n$ collection of voxels.
\end{itemize}

\subsection*{Core project}
The core element of the project involves implementing the ray marcher
for the structures, and implementing a system that should allow
for easy swapping between them. This system should also allow for different
scenes to be loaded, so that each structure can be compared in various layouts.

The aim is the compare the structures for the efficiency in
rendering, memory, and register pressure
on the GPU. The render time and memory usage can be measured directly
through Vulkan, while external tools can measure the register
pressure of a shader by inspecting the generated SPIR-V shader code.

\subsection*{Extensions}
The extensions add functionality to the core project. These functions include:
modification of the structures, and generation of the structures.
Generation will be required within the core project, however it will
be once at the start of the program, the extension will aim to bring
the generation to either real-time, or implement the generation as to
not affect the main render thread.

Another larger extension involves split rendering. This is the
process of rendering the scene across multiple platforms, in particular
this may involve partial rendering or pre-processing of the scene on one
platform, and then finishing the rendering and display of the scene on a
separate platform. This can be particularly useful for cloud gaming,
where latency is a concern. The splitting can reduce latency as the client
can perform some of the calculation, while still reducing the resource
requirements of the client system in order to render the scene.
